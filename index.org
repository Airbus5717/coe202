#+TITLE: COE 202 notes - Airbus5717
#+OPTIONS: num:nil html-style:nil toc:1
#+AUTHOR: Airbus5717
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+html_head: <link rel="stylesheet" type="text/css" href="style.css">
#+LaTeX_HEADER: \usepackage{minted}

-----
#+begin_quote
IMPORTANT NOTICE:
- Mobile screens may not display the web page properly due to alignment issues
- These notes are not enough for high grade (u need to practice and read the slides)
- Notes does not cover the whole material
- Every Professor teaches with a different ordering for courses
- These notes are according to Dr. Al-Suwaiyan's order of sections
- source of the notes are on [[https://github.com/airbus5717/coe202]]
- This document is generated by orgmode with the emacs text editor
#+end_quote
-----

* resources
** GOOGLE DRIVE
[[https://drive.google.com/drive/folders/1uj0pIcEBduEHoKZDmaap0oEAX33aH5U7?usp=sharing][click here]]
** Videos
*** Dr. M. Mudawar
+ YouTube playlist:  [[https://www.youtube.com/playlist?list=PLjusC38NfWcP2q64XNIHhEOy4pHZzNY3m][click here]]

*** Dr. Aiman El-Maleh
+ Microsoft stream videos: [[https://web.microsoftstream.com/user/3bc9969e-64c5-4a29-8579-93820cc76ef6][click here]]

*** Dr. Ali Al-Suwaiyan
+ YouTube playlist: [[https://www.youtube.com/playlist?list=PLeurb_BIjrxifPpf5Z1B5nSNmwI_GHXFZ][click here]]

| UNIT (For Suwaiyan)                          | YT video lecture         |
|----------------------------------------------+--------------------------|
| 1. Numbering systems                         | 1-5                      |
| 2. Boolean algebra                           | 6-8                      |
| 3. Std and canonical forms                   | 9-10                     |
| 4. Verilog(1/3)                              | 11, 11.5                 |
| 5. K-Map simplification                      | 12-15(till min 24)       |
| 6. Other gate types                          | (contine)15-17           |
| 7. Combination Logic Design Procedure        | 18 (till min 24)         |
| 8. Arithmetic Circuits                       | (continue) 18-23         |
| 9. Functional blocks                         | 24-28                    |
| 10. Verilog(2/3)                             | 29.1, 29.2, homework 1-2 |
| 11. Analysis & Design of Sequential Circuits | 30-34                    |
| 12. Registers and counters                   | 35-38(till min 20)       |
| 13. Verilog(3/3)                             | (contine)38-39           |
| 14. review                                   | 40                       |
-----



-----
* Data Representation

** Introduction
- computers represent data in binary numbers (1 and 0)
- all data must be represented in binary format
- data could be numbers, alphanumeric characters, images, sounds and many more.
- in general they are (numbers and characters)

-----
** Numbering Systems
- Numbering systems are characterized by their base number (also called radix or r for short)
- a number with base n will have digits from 0 to (n-1)
- for example base 2 includes : 0 and 1
- the widely used numbering systems are:
   | Numbering system | Base | digits set         |
   |------------------+------+--------------------|
   | Binary           |    2 | 0, 1               |
   | Octal            |    8 | 0, ..., 7          |
   | Decimal          |   10 | 0, 1, ..., 9       |
   | Hexadecimal      |   16 | 0, ... 9, A, ... F |

-----
** Weighted Number Systems
 - a number =D= consists of =n= digits with each digit having a particular position.
 - Every Digit has a fixed weight

 [[./res/unit1-wns.png]] (from el-maleh slides)

 - for example in base 10: =10 = 1 * 10 + 0 * 10=
-----
** The Radix (=Base=)
the allowed set of digits are from =0= to =r-1=
for example in base 8: =0...7=
- revise the (El-Maleh's) slides (7-12)
-----
*** Digit weight
example a number in base 8: =34556=
- the most significant digit (MSD) is : =3=
- the least significant digit (LSD) is : =6=
-----
** Binary System
- the r = =2=
- each digit is either 1 or 0
- each bit represents a power of 2
 |  2^n | Decimal value |
 |------+---------------|
 |  2^0 |             1 |
 |  2^1 |             2 |
 |  2^2 |             4 |
 |  2^3 |             8 |
 |  2^4 |            16 |
 |  2^5 |            32 |
 |  2^6 |            64 |
 |  2^7 |           128 |
 |  2^8 |           256 |
 |  2^9 |           512 |
 | 2^10 |          1024 |
- example of conversion from binary to decimal
  binary number (101)
  = 1 * 2^2 + 0 * 2^1 + 1 * 2^0
  = 5 in decimal
- see a YouTube video on conversion from decimal to binary [[https://www.youtube.com/watch?v=rsxT4FfRBaM][click here]]
- another one on from binary to decimal [[https://www.youtube.com/watch?v=VLflTjd3lWA][click here]]

** Octal System
- r = 8
- Octal digits = {0, 1, 2, 3, 4, 5, 6, 7}
- conversion videos [[https://www.youtube.com/watch?v=YCM2JReWS10][click here for octal 2 decimal]] and [[https://www.youtube.com/watch?v=ayul1fmZd0Y][click here for decimal 2 octal]]

** Hexadecimal System
- r = 16
- Digits are 0..9 then A, B, C, D, E, F
- F is equavilant to 15 in decimal
- conversion videos [[https://www.youtube.com/watch?v=QJW6qnfhC70][click here for deci 2 hex]] and [[https://www.youtube.com/watch?v=pg-HEGBpCQk][click here for hex 2 deci]]
  also [[https://www.youtube.com/watch?v=D_YC6DSPpQE][click here for hex 2 binary]] and [[https://www.youtube.com/watch?v=tSLKOKGQq0Y][click here for binary 2 hex]].
-----
** Integers in (Binary, Octal, Decimal and Hexadecimal)
| Binary(2) | Octal(8) | Decimal(10) | Hexadecimal(16) |
|-----------+----------+-------------+-----------------|
|      0000 |        0 |           0 |               0 |
|      0001 |        1 |           1 |               1 |
|      0010 |        2 |           2 |               2 |
|      0011 |        3 |           3 |               3 |
|      0100 |        4 |           4 |               4 |
|      0101 |        5 |           5 |               5 |
|      0110 |        6 |           6 |               6 |
|      0111 |        7 |           7 |               7 |
|      1000 |       10 |           8 |               8 |
|      1001 |       11 |           9 |               9 |
|      1010 |       12 |          10 |               A |
|      1011 |       13 |          11 |               B |
|      1100 |       14 |          12 |               C |
|      1101 |       15 |          13 |               D |
|      1110 |       16 |          14 |               E |
|      1111 |       17 |          15 |               F |
-----
** Binary coded decimal
- every number is represented as 4 bits
- there are different ways to represent it
  - BCD8421 way is like for 1: 0001 and so forth
  - XS-3 is like BCD8421 but add 3 to BCD8421
- example 103
  - BCD8421: 0001 0000 0011
  - XS-3:    0100 0011 0110

** ASCII Chars
- each number/char/symbol is represented with a number from 0 to 127
- extended ascii has to 256 numbers
- ascii table [[https://en.cppreference.com/w/cpp/language/ascii][link]]

** Error detection by parity bit
- Sender tries to send data to reciever which is encodeded in binary
- Data could get corrupted during transmission
- so basically we construct a basic error checker that would help reduce errors (but not always the case)
*** Parity Bit
- We choose an even or odd parity bit
- Even parity: number of 1s is even
  - add zero to keep the 1s even
- Odd parity: number of 1s is odd
  - add zero to keep the 1s odd

check slides for example
-----

* Binary Logic and Gates
** Boolean Algebra
Digital circuts use binary Systems, signals can be either logic '0' or '1' corresponding to High(1) or Low(0) voltages.
- Digital Circuts take binary signals and produce binary signals
- Binary logic algebra is commonly referred to as binary algebra
- Algebric structure with
  - Booleans = {0 , 1}
  - Two Binary Operators = {., +}
    - the dot =.= represents =AND=
    - the plus sign =+= represents =OR=
  - One Unary operator = (written as a Dash above the symbol or as ='= after the symbol)
- Example =F = A.B + 1=
*** Operator precedence
1. Parethesis =( Expression )= {Highest priority}
2. =NOT= operator =Expr'=
3. =AND= operator =Expr1 . Expr2=
4. =OR= operator =Expr1 + Expr2= {Lowest priority}
-----
** Logic Gates & Operations
Gate drawings are from wikimedia (C)
*** =AND= Gate
[[https://upload.wikimedia.org/wikipedia/commons/b/b9/AND_ANSI_Labelled.svg]]

Truth table for (AB) or (A*B)
| A | B | AB |
|---+---+----|
| 0 | 0 |  0 |
| 0 | 1 |  0 |
| 1 | 0 |  0 |
| 1 | 1 |  1 |
-----

*** =OR= Gate
[[https://upload.wikimedia.org/wikipedia/commons/1/16/OR_ANSI_Labelled.svg]]

Truth Table for (A+B)
| A | B | A+B |
|---+---+-----|
| 0 | 0 |   0 |
| 0 | 1 |   1 |
| 1 | 0 |   1 |
| 1 | 1 |   1 |
-----

*** =NOT= Gate
[[https://upload.wikimedia.org/wikipedia/commons/6/60/NOT_ANSI_Labelled.svg]]

Truth Table for (A')
| A | A' |
|---+----|
| 0 |  1 |
| 1 |  0 |
-----

*** =NAND= Gate
[[https://upload.wikimedia.org/wikipedia/commons/e/e6/NAND_ANSI_Labelled.svg]]

Truth Table for (AB)'
| A | B | (AB)' |
|---+---+-------|
| 0 | 0 |     1 |
| 0 | 1 |     1 |
| 1 | 0 |     1 |
| 1 | 1 |     0 |
-----

*** =NOR= Gate
[[https://upload.wikimedia.org/wikipedia/commons/c/c6/NOR_ANSI_Labelled.svg]]

Truth Table for (A+B)'
| A | B | (A+B)' |
|---+---+--------|
| 0 | 0 |      1 |
| 0 | 1 |      0 |
| 1 | 0 |      0 |
| 1 | 1 |      0 |
-----

*** =XOR= Gate
[[https://upload.wikimedia.org/wikipedia/commons/1/17/XOR_ANSI_Labelled.svg]]

Truth Table for (A XOR B)
| A | B | A XOR B |
|---+---+---------|
| 0 | 0 |       0 |
| 0 | 1 |       1 |
| 1 | 0 |       1 |
| 1 | 1 |       0 |
-----

*** =XNOR= Gate
[[https://upload.wikimedia.org/wikipedia/commons/b/b8/XNOR_ANSI_Labelled.svg]]

Truth Table for (A XNOR B)
| A | B | A XNOR B |
|---+---+----------|
| 0 | 0 |        1 |
| 0 | 1 |        0 |
| 1 | 0 |        0 |
| 1 | 1 |        1 |
-----

#+begin_verse
NOTE: solve a few problems on slides and etc.
#+end_verse

** Basic Identities and Duality principle
Identities Table

| Prop.Name      | Expression         | Dual                         |
|----------------+--------------------+------------------------------|
| Identity       | X + 0 = X          | X . 1 = X                    |
| NULL           | X + 1 = 1          | X . 0 = 0                    |
| Idempotence    | X + X = X          | XX = X                       |
| Complement     | X + X' = 1         | XX'= 0                       |
| Commutative    | X+Y = Y+X          | XY = XY                      |
| Associative    | (X+Y)+Z = X+(Y+Z)  | (XY)Z = X(YZ)                |
| Distributive   | X(Y+Z) = XY + XZ   | X+YZ = (X+Y)(X+Z)            |
| Absorption     | X + XY = X         | X(X + Y) = X                 |
| Minimization   | XY + X'Y = Y       | (X+Y)(X' + Y) = Y            |
| Simplification | X + X'Y = X+Y      | X(X'+ Y) = XY                |
| Consensus      | XY+X'Z+YZ = XY+X'Z | (X+Y)(X'+Z)(Y+Z)=(X+Y)(X'+Z) |
| DeMorgan's     | (X+Y)' = X'Y'      | (XY)' = X' + Y'              |

*** to get a dual
- Change every =AND= to =OR= (. to +)
- Change every =OR= to =AND= (+ to .)
- Complement variables
  - change 1 to 0
  - change 0 to 1

#+begin_verse
Dual can be used to simplify a function but must be dualed back and the simplification
#+end_verse
-----
** Algerbraic Manipulations
#+begin_verse
Solve problems in Suwaiyan slides from [BooleanAlgebra slides]
from page 11 to 16

also practice more
#+end_verse
-----
* TODO Standard & Canonical Forms
** Canonical form
*** Minterms
Minterm is a =product term= which all literals show up the product in true or compliment form

- ABC is a minterm
- AB'C' is a minterm
- AB is not a minterm (missing C)


example:
M2 = A'BC' = because 2 is =010=
M6 = ABC' = =110=


#+begin_quote
- minterms are boolean functions
- a minterm will be 1 only once in the Truth Table (TT)
- (mi) will be 1 at row i of TT and 0 otherwise
#+end_quote
example:

| A | B | C | m3 | m5 | m6 |
|---+---+---+----+----+----|
| 0 | 0 | 0 |  0 |  0 |  0 |
| 0 | 0 | 1 |  0 |  0 |  0 |
| 0 | 1 | 0 |  0 |  0 |  0 |
| 0 | 1 | 1 |  1 |  0 |  0 |
| 1 | 0 | 0 |  0 |  0 |  0 |
| 1 | 0 | 1 |  0 |  1 |  0 |
| 1 | 1 | 0 |  0 |  0 |  1 |
| 1 | 1 | 1 |  0 |  0 |  0 |

-----
*** Sum of minterms
All boolean functions can be written in sum-of-minterms(SOM) form

- x'y = 01
- xy' = 10


=F(x, y) = m1 + m2 = x'y + xy'=

**** Example: express G(a, b, c) in TT below in SOM canonical form using SIGMA(Σ) notation

| a | b | c | G |
|---+---+---+---|
| 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 0 |

- G(a, b, c) = Σm(0, 2, 5)
- G(a, b, c) = a'b'c' + a'bc' + ab'c

*** Maxterms
Maxterm: Sum term where all literals show up the sum in true or complement form


maxterm examples
- A + B + C'
- A'+ B' + C'
- A + C (WARN: NOT A MAXTERM (B is missing))

| A | B | C | F | M1 | M4 | M7 |
|---+---+---+---+----+----+----|
| 0 | 0 | 0 | 1 |  1 |  1 |  1 |
| 0 | 0 | 1 | 0 |  0 |  1 |  1 |
| 0 | 1 | 0 | 1 |  1 |  1 |  1 |
| 0 | 1 | 1 | 1 |  1 |  1 |  1 |
| 1 | 0 | 0 | 0 |  1 |  0 |  1 |
| 1 | 0 | 1 | 1 |  1 |  1 |  1 |
| 1 | 1 | 0 | 1 |  1 |  1 |  1 |
| 1 | 1 | 1 | 0 |  1 |  1 |  0 |
F(A, B, C) = M1*M4*M7 = πM(1, 4, 7)

#+begin_quote
Use DeMorgan's law to convert between the two canonical forms
#+end_quote

**** Example: G(A, B, C) = Σm(1, 3, 4)
G(A, B, C) = m1 + m3 + m4
G(A, B, C) = πM(0, 2, 5, 6, 7)

**** Another example: F(A,B,C,D) = πM(0, 1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 14)
convert to SOM
F(A,B,C,D) = Σm(7, 19, 15)

**** Example3: express F' in POM and SOM
F'(A,B,C,D) = πM(7,9,15)
F'(A,B,C,D) = Σm(0,1,2,3,4,5,6,8,10,11,12,13,14)

-----
*** Operations on Canonical forms
**** ANDing two SOMs
take the intersection of indecies
**** ORing two SOMs
take union indecies
**** ANDing two POMs
union
**** ORing two POMs
intersection

**** Example
F(A,B,C) = Σm(0, 1, 3, 5)
G(A,B,C) = πM(1, 2, 3, 4)

- F * G = (Σm(0, 1, 3, 5)) * (πM(1, 2, 3, 4))

  = πM(2,4,6,7) * πM(1,2,3,4)

  = πM(1,2,3,4,6,7)

- F + G = (Σm(0, 1, 3, 5)) + (Σm(0, 5, 6, 7))

  = Σm(0,1,3,5,6,7)

- F + G in POM? = πM(2, 4)
-----

** Standard form
a product term is an ANDing of one or more literals



* TODO Other Gate types
* TODO Verilog (1/3)

#+begin_src verilog
// an example file with test benchmark
module fun1(output f1, input a, b, c);
 and(m0, ~a, ~b, ~c);
 and(m3, ~a, b ,c);
 and(m6, a, b , ~c);
 and(m7, a, b, c);
 or(f1, m0, m3, m6, m7);
endmodule
module fun2(output f2, input a, b, c);
 assign M1 = a | b | ~c;
 assign M2 = a | ~b | c;
 assign M4 = ~a | b | c;
 assign M5 = ~a | b | ~c;
 assign f2 = M1 & M2 & M4 & M5;
endmodule

module tb;
 reg a, b, c;
 wire f1, f2, EQ;
 fun1 fun10(f1, a, b, c);
 fun2 fun20(f2, a, b, c);
 xnor(EQ, f1, f2);
 integer t;
 initial begin
$dumpfile("dump.vcd"); $dumpvars;
  for (t=0; t<8; t=t+1) begin
   #1 {a, b, c} = t[2:0];
  end
  $finish();
 end
endmodule

#+end_src
